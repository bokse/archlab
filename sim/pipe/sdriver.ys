#######################################################################
# Test for copying block of size 4;
#######################################################################
	.pos 0
main:	
  irmovl Stack, %esp    # Set up stack pointer
  irmovl Stack, %ebp    # Set up base pointer

	# Set up arguments for copy function and then invoke it
	irmovl $4, %eax # concatenate 4 elements from src to dst
	pushl %eax
	irmovl dest, %eax	# dst array
	pushl %eax
	irmovl src, %eax	# src array
	pushl %eax
	call ncopy		 
	halt			# should halt with num nonzeros in %eax
StartFun:
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Concatenates a src block of len ints to dst.
# Return the number of positive ints (>0) contained in src.
#
# 2014-18912 Ji Jeongwoo
# Describe how and why you modified the baseline code.
# Loop&Npos is executed for all element.(in original code)
# Instructions of Loop is necessary. irreducible.
# If we consider many block in once, instructions of Npos are only executed sometimes.
# I consider 10 blocks once.
#
# (*) Note: Pseudo-end of array is 0xccaaff.
##################################################################
# Do not modify this portion (Function Prolog)
ncopy:  pushl %ebp    # Save old frame pointer
  rrmovl %esp,%ebp    # Set up new frame pointer
  pushl %esi          # Save callee-save regs
  pushl %ebx
  pushl %edi
  mrmovl 8(%ebp),%ebx   # src
  mrmovl 16(%ebp),%edx  # len
  mrmovl 12(%ebp),%ecx  # dst
##################################################################
# You can modify this portion 
  irmovl $0xccaaff,%edi # edi = pseudo-end
  isubl $4,%ecx
Move:
  iaddl $4,%ecx
  mrmovl (%ecx),%esi    # *dst++
  xorl %edi,%esi
  jne Move              # not? goto Move
  iaddl $4,%ecx
  xorl %eax,%eax		# count=0
Loop:
  isubl $15, %edx		# len<2? (len=len-2)
  jl Rest
Loop1:
  mrmovl (%ebx), %esi   # read val from src...
  rmmovl %esi, (%ecx)   # ...and store it to dst
  andl %esi, %esi       # val <= 0?
  jle Loop2			# if so, goto Npos:
  iaddl $1,%eax
Loop2:
  mrmovl 4(%ebx), %esi
  rmmovl %esi, 4(%ecx)
  andl %esi, %esi		# val<=0?
  jle Loop3
  iaddl $1,%eax
Loop3:
  mrmovl 8(%ebx), %esi
  rmmovl %esi, 8(%ecx)
  andl %esi, %esi
  jle Loop4
  iaddl $1, %eax
Loop4:
  mrmovl 12(%ebx), %esi
  rmmovl %esi, 12(%ecx)
  andl %esi, %esi
  jle Loop5
  iaddl $1, %eax
Loop5:
  mrmovl 16(%ebx), %esi
  rmmovl %esi, 16(%ecx)
  andl %esi, %esi
  jle Loop6
  iaddl $1, %eax
Loop6:
  mrmovl 20(%ebx), %esi
  rmmovl %esi, 20(%ecx)
  andl %esi, %esi
  jle Loop7
  iaddl $1, %eax
Loop7:
  mrmovl 24(%ebx), %esi
  rmmovl %esi, 24(%ecx)
  andl %esi, %esi
  jle Loop8
  iaddl $1, %eax
Loop8:
  mrmovl 28(%ebx), %esi
  rmmovl %esi, 28(%ecx)
  andl %esi, %esi
  jle Loop9
  iaddl $1, %eax
Loop9:
  mrmovl 32(%ebx), %esi
  rmmovl %esi, 32(%ecx)
  andl %esi, %esi
  jle Loop10
  iaddl $1, %eax
Loop10:
  mrmovl 36(%ebx), %esi
  rmmovl %esi, 36(%ecx)
  andl %esi, %esi
  jle Loop11
  iaddl $1, %eax
Loop11:
  mrmovl 40(%ebx), %esi
  rmmovl %esi, 40(%ecx)
  andl %esi, %esi
  jle Loop12
  iaddl $1, %eax
Loop12:
  mrmovl 44(%ebx), %esi
  rmmovl %esi, 44(%ecx)
  andl %esi, %esi
  jle Loop13
  iaddl $1, %eax
Loop13:
  mrmovl 48(%ebx), %esi
  rmmovl %esi, 48(%ecx)
  andl %esi, %esi
  jle Loop14
  iaddl $1, %eax
Loop14:
  mrmovl 52(%ebx), %esi
  rmmovl %esi, 52(%ecx)
  andl %esi, %esi
  jle Loop15
  iaddl $1, %eax
Loop15:
  mrmovl 56(%ebx), %esi
  rmmovl %esi, 56(%ecx)
  andl %esi, %esi
  jle Loopfin
  iaddl $1, %eax
Loopfin:
  iaddl $60, %ebx
  iaddl $60, %ecx
  jmp Loop

Rest:
  iaddl $15, %edx		#len=len+2
  je Done				#if len==0 -> Done
  mrmovl (%ebx),%esi
  rmmovl %esi,(%ecx)
  andl %esi,%esi
  jle Rest2
  iaddl $1,%eax
Rest2:
  isubl $1, %edx
  je Done
  mrmovl 4(%ebx),%esi
  rmmovl %esi,4(%ecx)
  andl %esi,%esi
  jle Rest3
  iaddl $1,%eax
Rest3:
  isubl $1, %edx
  je Done
  mrmovl 8(%ebx),%esi
  rmmovl %esi,8(%ecx)
  andl %esi,%esi
  jle Rest4
  iaddl $1,%eax
Rest4:
  isubl $1, %edx
  je Done
  mrmovl 12(%ebx),%esi
  rmmovl %esi,12(%ecx)
  andl %esi,%esi
  jle Rest5
  iaddl $1,%eax
Rest5:
  isubl $1, %edx
  je Done
  mrmovl 16(%ebx),%esi
  rmmovl %esi,16(%ecx)
  andl %esi,%esi
  jle Rest6
  iaddl $1,%eax
Rest6:
  isubl $1, %edx
  je Done
  mrmovl 20(%ebx),%esi
  rmmovl %esi,20(%ecx)
  andl %esi,%esi
  jle Rest7
  iaddl $1,%eax
Rest7:
  isubl $1, %edx
  je Done
  mrmovl 24(%ebx),%esi
  rmmovl %esi,24(%ecx)
  andl %esi,%esi
  jle Rest8
  iaddl $1,%eax
Rest8:
  isubl $1, %edx
  je Done
  mrmovl 28(%ebx),%esi
  rmmovl %esi,28(%ecx)
  andl %esi,%esi
  jle Rest9
  iaddl $1,%eax
Rest9:
  isubl $1, %edx
  je Done
  mrmovl 32(%ebx),%esi
  rmmovl %esi,32(%ecx)
  andl %esi,%esi
  jle Rest10
  iaddl $1,%eax
Rest10:
  isubl $1, %edx
  je Done
  mrmovl 36(%ebx),%esi
  rmmovl %esi,36(%ecx)
  andl %esi,%esi
  jle Rest11
  iaddl $1,%eax
Rest11:
  isubl $1, %edx
  je Done
  mrmovl 40(%ebx),%esi
  rmmovl %esi,40(%ecx)
  andl %esi,%esi
  jle Rest12
  iaddl $1,%eax
Rest12:
  isubl $1, %edx
  je Done
  mrmovl 44(%ebx),%esi
  rmmovl %esi,44(%ecx)
  andl %esi,%esi
  jle Rest13
  iaddl $1,%eax
Rest13:
  isubl $1, %edx
  je Done
  mrmovl 48(%ebx),%esi
  rmmovl %esi,48(%ecx)
  andl %esi,%esi
  jle Rest14
  iaddl $1,%eax
Rest14:
  isubl $1, %edx
  je Done
  mrmovl 52(%ebx),%esi
  rmmovl %esi,52(%ecx)
  andl %esi,%esi
  jle Done
  iaddl $1,%eax
##################################################################
# Do not modify the following section of code (Function epiloge)
Done:
  popl %edi               # Restore callee-save registers
  popl %ebx
  popl %esi
  rrmovl %ebp, %esp
  popl %ebp
  ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
EndFun:

###############################
# Source and destination blocks 
###############################
	.align 4
src:
	.long 1
	.long -2
	.long -3
	.long 4
	.long 0xbcdefa # This shouldn't get moved

	.align 16
Predest:
	.long 0xbcdefa
dest:
	.long 0xccaaff
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
Postdest:
	.long 0xdefabc

.align 4
# Run time stack
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0

Stack:
