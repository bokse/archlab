#######################################################################
# Test for copying block of size 63;
#######################################################################
	.pos 0
main:	
  irmovl Stack, %esp    # Set up stack pointer
  irmovl Stack, %ebp    # Set up base pointer

	# Set up arguments for copy function and then invoke it
	irmovl $63, %eax # concatenate 63 elements from src to dst
	pushl %eax
	irmovl dest, %eax	# dst array
	pushl %eax
	irmovl src, %eax	# src array
	pushl %eax
	call ncopy		 
	halt			# should halt with num nonzeros in %eax
StartFun:
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Concatenates a src block of len ints to dst.
# Return the number of positive ints (>0) contained in src.
#
# 2014-18912 Ji Jeongwoo
# Describe how and why you modified the baseline code.
# Loop&Npos is executed for all element.(in original code)
# Instructions of Loop is necessary. irreducible.
# If we consider many block in once, instructions of Npos are only executed sometimes.
# I consider 10 blocks once.
# Also, reduce bubble because of consecutive mrmovl and rmmovl by using esi and edi both.
#
# (*) Note: Pseudo-end of array is 0xccaaff.
##################################################################
# Do not modify this portion (Function Prolog)
ncopy:  pushl %ebp    # Save old frame pointer
  rrmovl %esp,%ebp    # Set up new frame pointer
  pushl %esi          # Save callee-save regs
  pushl %ebx
  pushl %edi
  mrmovl 8(%ebp),%ebx   # src
  mrmovl 16(%ebp),%edx  # len
  mrmovl 12(%ebp),%ecx  # dst
##################################################################
# You can modify this portion 
  irmovl $0xccaaff,%edi # edi = pseudo-end
  isubl $4,%ecx
Move:
  iaddl $4,%ecx
  mrmovl (%ecx),%esi    # *dst++
  xorl %edi,%esi
  jne Move              # not? goto Move
  iaddl $4,%ecx
  xorl %eax,%eax		# count=0
Loop:
  isubl $10, %edx		# len<10? (len=len-10)
  jl Rest10
Loop1:
  mrmovl (%ebx), %esi   # read val from src...
  mrmovl 4(%ebx), %edi
  rmmovl %esi, (%ecx)   # ...and store it to dst
  andl %esi, %esi       # val <= 0?
  jle Loop2			# if so, goto Npos:
  iaddl $1,%eax
Loop2:
  rmmovl %edi, 4(%ecx)
  andl %edi, %edi		# val<=0?
  jle Loop3
  iaddl $1,%eax
Loop3:
  mrmovl 8(%ebx), %esi
  mrmovl 12(%ebx), %edi
  rmmovl %esi, 8(%ecx)
  andl %esi, %esi
  jle Loop4
  iaddl $1, %eax
Loop4:
  rmmovl %edi, 12(%ecx)
  andl %edi, %edi
  jle Loop5
  iaddl $1, %eax
Loop5:
  mrmovl 16(%ebx), %esi
  mrmovl 20(%ebx), %edi
  rmmovl %esi, 16(%ecx)
  andl %esi, %esi
  jle Loop6
  iaddl $1, %eax
Loop6:
  rmmovl %edi, 20(%ecx)
  andl %edi, %edi
  jle Loop7
  iaddl $1, %eax
Loop7:
  mrmovl 24(%ebx), %esi
  mrmovl 28(%ebx), %edi
  rmmovl %esi, 24(%ecx)
  andl %esi, %esi
  jle Loop8
  iaddl $1, %eax
Loop8:
  rmmovl %edi, 28(%ecx)
  andl %edi, %edi
  jle Loop9
  iaddl $1, %eax
Loop9:
  mrmovl 32(%ebx), %esi
  mrmovl 36(%ebx), %edi
  rmmovl %esi, 32(%ecx)
  andl %esi, %esi
  jle Loop10
  iaddl $1, %eax
Loop10:
  rmmovl %edi, 36(%ecx)
  andl %edi, %edi
  jle Loopfin
  iaddl $1, %eax
Loopfin:
  iaddl $40, %ebx
  iaddl $40, %ecx
  jmp Loop

Rest10:
  iaddl $5, %edx		#len=len+5
  jl Rest51				#if len<0 -> Rest51
R11:
  mrmovl (%ebx),%esi
  rmmovl %esi,(%ecx)
  andl %esi,%esi
  jle R12
  iaddl $1,%eax
R12:
  mrmovl 4(%ebx),%esi
  rmmovl %esi,4(%ecx)
  andl %esi,%esi
  jle R13
  iaddl $1,%eax
R13:
  mrmovl 8(%ebx),%esi
  rmmovl %esi,8(%ecx)
  andl %esi,%esi
  jle R14
  iaddl $1,%eax
R14:
  mrmovl 12(%ebx),%esi
  rmmovl %esi,12(%ecx)
  andl %esi,%esi
  jle R15
  iaddl $1,%eax
R15:
  mrmovl 16(%ebx),%esi
  rmmovl %esi,16(%ecx)
  andl %esi,%esi
  jle Rest10F
  iaddl $1,%eax
Rest10F:
  iaddl $20,%ebx
  iaddl $20,%ecx
  isubl $5,%edx
Rest51:
  iaddl $4, %edx
  jl Done
  mrmovl (%ebx),%esi
  rmmovl %esi,(%ecx)
  andl %esi,%esi
  jle Rest52
  iaddl $1,%eax
Rest52:
  isubl $1, %edx
  jl Done
  mrmovl 4(%ebx),%esi
  rmmovl %esi,4(%ecx)
  andl %esi,%esi
  jle Rest53
  iaddl $1,%eax
Rest53:
  isubl $1, %edx
  jl Done
  mrmovl 8(%ebx),%esi
  rmmovl %esi,8(%ecx)
  andl %esi,%esi
  jle Rest54
  iaddl $1,%eax
Rest54:
  isubl $1, %edx
  jl Done
  mrmovl 12(%ebx),%esi
  rmmovl %esi,12(%ecx)
  andl %esi,%esi
  jle Done
  iaddl $1,%eax
##################################################################
# Do not modify the following section of code (Function epiloge)
Done:
  popl %edi               # Restore callee-save registers
  popl %ebx
  popl %esi
  rrmovl %ebp, %esp
  popl %ebp
  ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
EndFun:

###############################
# Source and destination blocks 
###############################
	.align 4
src:
	.long -1
	.long 2
	.long 3
	.long 4
	.long -5
	.long 6
	.long 7
	.long 8
	.long 9
	.long 10
	.long 11
	.long 12
	.long -13
	.long 14
	.long -15
	.long 16
	.long 17
	.long 18
	.long -19
	.long 20
	.long 21
	.long -22
	.long 23
	.long -24
	.long -25
	.long 26
	.long 27
	.long -28
	.long -29
	.long -30
	.long -31
	.long 32
	.long 33
	.long -34
	.long 35
	.long 36
	.long 37
	.long 38
	.long 39
	.long 40
	.long -41
	.long -42
	.long 43
	.long -44
	.long 45
	.long 46
	.long 47
	.long -48
	.long -49
	.long -50
	.long -51
	.long -52
	.long -53
	.long -54
	.long -55
	.long -56
	.long -57
	.long -58
	.long -59
	.long -60
	.long -61
	.long -62
	.long -63
	.long 0xbcdefa # This shouldn't get moved

	.align 16
Predest:
	.long 0xbcdefa
dest:
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xccaaff
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
	.long 0xffaacc
Postdest:
	.long 0xdefabc

.align 4
# Run time stack
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0

Stack:
